// Editable main battle menu
// by JTolmar
// Including this will replace the main battle menu, and the auto fight AI, with  relatively readable CCS commands,
// instead of assembly spaghetti code. This makes it a lot easier to edit them.
// The only differences from vanilla behavior (until you edit it) are that it always uses the large battle window
// (window 48), that some of the text positions are different, and that the cursor position resets when cancelling
// out of sub-menus.
// Read through the provided commands to find out what's available. There's more included than is used in
// just recreating the main menu. Also don't forget if_flag()! Which is in menu_macros.
import asm65816
import jsl_rts
import menu_macros

import BowsprBattleSystem_Flags

// Edit this menu to change the battle menu.
define battle_menu = {
  do_menu(48, CANCELLABLE, { // 48 is which window. Make sure the 48 at the bottom of this define matches
    reset_action() // Leave this line in to prevent weird bugs
	
    // Rest of this is editable; it's pre-configured to mimic the original menu decently well.
    set_window_title_to_character_name(48)
	
	// Check for who is currently at the menu and reset battle flags for that character
	if_character_id(1, {
		set_flag(NESS_DEF_FLAG, 0)
		set_flag(NESS_PSI_FLAG, 0)
		set_flag(NESS_GOODS_FLAG, 0)
		set_flag(PARTY_RUNAWAY_FLAG, 0)
		
		set_flag(PAULA_DEF_FLAG, 0)
		set_flag(PAULA_PSI_FLAG, 0)
		set_flag(PAULA_GOODS_FLAG, 0)
		set_flag(PAULA_PRAY_FLAG, 0)
		
		set_flag(JEFF_DEF_FLAG, 0)
		set_flag(JEFF_SPY_FLAG, 0)
		set_flag(JEFF_GOODS_FLAG, 0)
		
		set_flag(POO_DEF_FLAG, 0)
		set_flag(POO_PSI_FLAG, 0)
		set_flag(POO_GOODS_FLAG, 0)
		
	})
	if_character_id(2, {
		set_flag(PAULA_DEF_FLAG, 0)
		set_flag(PAULA_PSI_FLAG, 0)
		set_flag(PAULA_GOODS_FLAG, 0)
		set_flag(PAULA_PRAY_FLAG, 0)
		
		set_flag(JEFF_DEF_FLAG, 0)
		set_flag(JEFF_SPY_FLAG, 0)
		set_flag(JEFF_GOODS_FLAG, 0)
		
		set_flag(POO_DEF_FLAG, 0)
		set_flag(POO_PSI_FLAG, 0)
		set_flag(POO_GOODS_FLAG, 0)
	})
	if_character_id(3, {
		set_flag(JEFF_DEF_FLAG, 0)
		set_flag(JEFF_SPY_FLAG, 0)
		set_flag(JEFF_GOODS_FLAG, 0)
		
		set_flag(POO_DEF_FLAG, 0)
		set_flag(POO_PSI_FLAG, 0)
		set_flag(POO_GOODS_FLAG, 0)
	})
	if_character_id(4, {
		set_flag(POO_DEF_FLAG, 0)
		set_flag(POO_PSI_FLAG, 0)
		set_flag(POO_GOODS_FLAG, 0)
	})
	
    // Paralysis-effected stuff
    if_can_move_else({
      if_character_id(1, {
        menu_option("Bash", 0, 0, {
          set_action(4)
          ret_target()
        })
      })
	  
	  if_character_id(2, {
        menu_option("Bash", 0, 0, {
          set_action(86)
          ret_target()
        })
      })
	  
	  if_character_id(3, {
        if_equipped_type_else(SLOT_WEAPON, 17, {
          menu_option("Shoot", 0, 0, {
            set_action(5)
            ret_target()
          })
        }, {
          menu_option("Bash", 0, 0, {
            set_action(124)
            ret_target()
          })
        })
	  })
	  
	  if_character_id(4, {
        menu_option("Bash", 0, 0, {
          set_action(125)
          ret_target()
        })
      })
	  
      menu_option("Goods", 6, 0, {
	    if_character_id(1, {
			set_flag(NESS_GOODS_FLAG, 1)
		})
		if_character_id(2, {
			set_flag(PAULA_GOODS_FLAG, 1)
		})
		if_character_id(3, {
			set_flag(JEFF_GOODS_FLAG, 1)
		})
		if_character_id(4, {
			set_flag(POO_GOODS_FLAG, 1)
		})
        ret_goods_menu()
      })
      menu_option("Defend", 6, 1, {
		if_character_id(1, {
			set_flag(NESS_DEF_FLAG, 1)
		})
		if_character_id(2, {
			set_flag(PAULA_DEF_FLAG, 1)
		})
		if_character_id(3, {
			set_flag(JEFF_DEF_FLAG, 1)
		})
		if_character_id(4, {
			set_flag(POO_DEF_FLAG, 1)
		})
        set_action_defend()
        ret_val(1)
      })
    }, {
      menu_option("Do nothing", 0, 0, {
        set_action(1)
        ret_val(1)
      })
    })
    // First kid moves
    if_first_character({
      menu_option("Auto Fight", 18, 0, {
        set_action_autofight()
        ret_val(1)
      })
      menu_option("Run away", 18, 1, {
        set_action_run_away()
		set_flag(PARTY_RUNAWAY_FLAG, 1)
        ret_val(1)
      })
    })
    // PSI
    if_not_character_id(3, {
      menu_option("PSI", 0, 1, {
        if_character_id(1, {
			set_flag(NESS_PSI_FLAG, 1)
		})
		if_character_id(2, {
			set_flag(PAULA_PSI_FLAG, 1)
		})
		if_character_id(4, {
			set_flag(POO_PSI_FLAG, 1)
		})
		ret_psi_menu()
		
      })
    })
    // Character specials
    if_character_id(2, {
      menu_option("Pray", 12, 0, {
        set_action(7) // Start with normal pray and let the giygas phases override it
        // You actually don't need the {}s if it's exactly one expression. Makes this less of a mess
        if_giygas_phase(4, set_action(291))
        if_giygas_phase(5, set_action(292))
        if_giygas_phase(6, set_action(293))
        if_giygas_phase(7, set_action(294))
        if_giygas_phase(8, set_action(295))
        if_giygas_phase(9, set_action(296))
        if_giygas_phase(10, set_action(297))
        if_giygas_phase(11, set_action(298))
        if_giygas_phase(12, set_action(299))
        ret_target()
      })
    })
    if_character_id(3, {
      menu_option("Spy", 0, 1, {
        set_flag(JEFF_SPY_FLAG, 1)
		set_action(6)
        ret_target()
      })
    })
    if_character_id(4, {
      menu_option("Mirror", 12, 0, {
		set_action(280)
        ret_target()
      })
    })
  })
  LDA_i(48) // Window ID, used to close window properly, should match the do_menu one up top
  JSL(0xC1DD4D) // setWindowFocusF(windowId)
}

// Edit this to change the auto fight AI
// Should end in RTS
AutoFightAi:
  reset_action()
  // Don't do any PSI if feeling strange or mushroomized
  if_not_confused({
    // Just a long list of PSI checks. This follows the vanilla priority order, dumb as that is.
    if_can_use_psi(26, { // lifeup omega
      if_at_least_n_characters(2, {
        if_lifeup_target(ALL_ALLIES, {
          set_action(35)
          set_psi_args(26)
          RTS
        })
      })
    })
    if_can_use_psi(25, { // lifeup gamma
      if_lifeup_target(ONE_ALLY, {
        set_action(34)
        set_psi_args(25)
        RTS
      })
    })
    if_can_use_psi(24, { // lifeup beta
      if_lifeup_target(ONE_ALLY, {
        set_action(33)
        set_psi_args(24)
        RTS
      })
    })
    if_can_use_psi(23, { // lifeup alpha
      if_lifeup_target(ONE_ALLY, {
        set_action(32)
        set_psi_args(23)
        RTS
      })
    })
    // lifeup is 23+, healing is 27+. Their actions are all 9 higher than their PSI
    if_can_use_psi(30, { // healing omega
      if_healing_target(ONE_ALLY, 0, 1, { // unconscious
        set_action(39)
        set_psi_args(30)
        RTS
      })
    })
    if_can_use_psi(29, { // healing gamma
      if_healing_target(ONE_ALLY, 0, 3, { // paralyzed
        set_action(38)
        set_psi_args(29)
        RTS
      })
      if_healing_target(ONE_ALLY, 0, 2, { // diamondized
        set_action(38)
        set_psi_args(29)
        RTS
      })
      if_healing_target(ONE_ALLY, 0, 1, { // unconscious
        set_action(38)
        set_psi_args(29)
        RTS
      })
    })
    if_can_use_psi(28, { // healing beta
      if_healing_target(ONE_ALLY, 0, 5, { // poisoned
        set_action(37)
        set_psi_args(28)
        RTS
      })
      if_healing_target(ONE_ALLY, 0, 4, { // nauseous
        set_action(37)
        set_psi_args(28)
        RTS
      })
      if_healing_target(ONE_ALLY, 2, 2, { // crying
        set_action(37)
        set_psi_args(28)
        RTS
      })
      if_healing_target(ONE_ALLY, 3, 1, { // feeling strange
        set_action(37)
        set_psi_args(28)
        RTS
      })
    })
    if_can_use_psi(27, { // healing alpha
      if_healing_target(ONE_ALLY, 0, 7, { // cold
        set_action(36)
        set_psi_args(27)
        RTS
      })
      if_healing_target(ONE_ALLY, 0, 6, { // sunstroke
        set_action(36)
        set_psi_args(27)
        RTS
      })
      if_healing_target(ONE_ALLY, 2, 1, { // asleep
        set_action(36)
        set_psi_args(27)
        RTS
      })
    })
  })
  // No PSI was used if we got here
  // Figure out whether we're bash/shoot/paralyzed
  if_can_move({
	if_character_id(1, {
		set_action(4)
	})
	if_character_id(2, {
		set_action(86)
	})
	if_character_id(3, {
		if_equipped_type_else(SLOT_WEAPON, 17, {
          set_action(5)
        }, {
          set_action(124)
        })
	})
	if_character_id(4, {
		set_action(125)
	})
    auto_target()
    RTS
  })
  // Can't move. Use the "no effect" action
  set_action(1)
  RTS

  
// Sets window title to the name of the current character (PARTY_CHARACTER)
command set_window_title_to_character_name(windowId) {
  // Load text pointer - the name is at the start of the char struct
  LDA_d(PARTY_CHARACTER)
  STA_d(0x0E)
  LDA_i(0x007e)
  STA_d(0x10)
  // Character names are not null-terminated, so we need to hard code the length
  LDX_i(5) // Change this if somebody made a character name length patch
  LDA_i(windowId)
  JSL(0xC2032B) // setWindowTitle
}

// Sets the current action to a regular one without an argument
command set_action(action) {
  LDA_i(action)
  STA_a(BATTLE_SELECTION_ACTION)
}

// Does target selection for the current action, and returns or cancels as appropriate
command ret_target() {
  LDA_a(BATTLE_SELECTION_ACTION)
  LDX_d(PARTY_ID)
  JSL_RTS_C1(0xC1ADB4) // determineTargetting(short actionId, short userId)
  // returns both targetting bits and target
  XBA // but they're swapped
  STA_a(BATTLE_SELECTION_TARGETTING)
  // determineTargetting returns 0 in the target (low byte) if cancelled.
  // ret_retry() is 0, so mask that to match
  AND_i(0xFF00)
  RTS
}

// Sets the action to "defend"
command set_action_defend() {
  LDA_i(8)
  STA_a(BATTLE_SELECTION_ACTION)
  LDA_i(0)
  STA_a(BATTLE_SELECTION_TARGETTING) // Not bothering with 8-bit mode, as far as I can tell the target isn't used
}

// Sets the action to "run away"
command set_action_run_away() {
  LDA_i(279)
  STA_a(BATTLE_SELECTION_ACTION)
  LDA_i(0)
  SEP(0x20) // accum8
  LDA_a(1)
  STA_a(BATTLE_SELECTION_TARGETTING)
  LDA_d(PARTY_ID)
  STA_a(BATTLE_SELECTION_TARGET)  
  REP(0x20) // accum8
}

// Turns on autofight
// You should really return right after this, none of the other codes clean it up properly
// This just turns on the autofight; what it actually does is completely different
command set_action_autofight() {
  LDA_i(1)
  SEP(0x20) // accum8
  STA_a(AUTO_FIGHT_ENABLE)
  REP(0x20) // accum8
	JSL(0xC20266) // drawAutoFightIcon()
	STZ_a(BATTLE_SELECTION_ACTION)
}


// Sets action arguments for an item use.
// You'll also need to call set_action()
// You don't need to use this if using the inventory
command set_item_args(item_id, item_slot) {
  SEP(0x20) // accum8
  LDA_8(item_id)
  STA_a(BATTLE_ITEM_USED)
  LDA_8(item_slot)
  STA_a(BATTLE_SELECTION_PARAM1)
  REP(0x20) // accum8
}

// Sets action arguments for psi use
// You'll also need to call set_action()
// You don't need to use this if using the psi menu
command set_psi_args(psi_id) {
  SEP(0x20) // accum8
  STZ_a(BATTLE_ITEM_USED)
  LDA_8(psi_id)
  STA_a(BATTLE_SELECTION_PARAM1)
  REP(0x20) // accum8
}


// Opens and uses the PSI menu for the current character
command ret_psi_menu() {
  LDA_d(PARTY_ID)
  SEP(0x20) // accum8
  STA_a(BATTLE_SELECTION_USER)
  REP(0x20) // accum8
  LDA_i(BATTLE_SELECTION) // This function requires this to be its arg lol
  JSL(0xC1DE3D) // battlePsiMenuF(BattleMenuSelection* arg)
  // Returns the right arguments already, including 0=retry
  RTS
}

// Opens and uses the goods menu (items) for the current character
command ret_goods_menu() {
  LDA_d(PARTY_ID)
  SEP(0x20) // accum8
  STA_a(BATTLE_SELECTION_USER)
  REP(0x20) // accum8
  LDA_i(BATTLE_SELECTION) // This function requires this to be its arg lol
  JSL(0xC1DE31) // battleSelectItemF(BattleMenuSelection* arg)
  CMP_i(0)
  BEQ_a(_end)
  // This function doesn't set battleItemUsed, so go do that
  LDA_a(BATTLE_SELECTION_PARAM1) // item index
  AND_i(0xFF) // param1 is one byte
  TAX
  LDA_d(PARTY_ID)
  JSL(0xC3E977) // short getCharacterItem(short character, short slot)
  SEP(0x20) // accum8
  STA_a(BATTLE_ITEM_USED)
  REP(0x20) // accum8
  // We need to return the action (which will be 0 if cancelled), so load that back
  LDA_a(BATTLE_SELECTION_ACTION)
_end:
  RTS
}

// Ends the battle instantly, with no "you won" message or EXP granted, like after beating Giygas
command escape_instantly() {
  set_action(-1)
  ret_val(1)
}

// Zeroes out a bunch of things that can get EB confused
// Should be called at top of battle menu
command reset_action() {
  STZ_a(BATTLE_ITEM_USED) // Also zeroes selection user
  STZ_a(BATTLE_SELECTION_PARAM1) // Bleeds into selection action, but we're zeroing it out too
  STZ_a(BATTLE_SELECTION_ACTION)
  STZ_a(BATTLE_SELECTION_TARGETTING) // Covers both targetting and target
}

// Does {code} if the current battle action is characterAction
// CUSTOM CODE
command if_character_action(characterAction, code) {
  LDA_a(BATTLE_SELECTION_ACTION)
  CMP_i(characterAction)
  BNE_a(_end)
  code
_end:
}

// Does {code} if the current character is characterId (1 Ness, 2 Paula, etc)
command if_character_id(characterId, code) {
  LDA_d(PARTY_ID)
  CMP_i(characterId)
  BNE_a(_end)
  code
_end:
}

// Does {code} if the current character is not characterId (1 Ness, 2 Paula, etc)
command if_not_character_id(characterId, code) {
  LDA_d(PARTY_ID)
  CMP_i(characterId)
  BEQ_a(_end)
  code
_end:
}

// Does {trueCode} if the current character is characterId, else does {falseCode}
command if_character_id_else(characterId, trueCode, falseCode) {
  LDA_d(PARTY_ID)
  CMP_i(characterId)
  BNE_a(_false)
  trueCode
  JMP(_end)
_false:
  falseCode
_end:
}

// Does {code} if the current character is the first character in the party
command if_first_character(code) {
  LDA_d(PARTY_ORDER)
  BNE_a(_end)
  code
_end:
}

// Does {code} if the current character is not the first character in the party
command if_not_first_character(code) {
  LDA_d(PARTY_ORDER)
  BEQ_a(_end)
  code
_end:
}

// Does {trueCode} if the current character is the first character in the party, else does {falseCode}
command if_first_character_else(trueCode, falseCode) {
  LDA_d(PARTY_ORDER)
  BNE_a(_false)
  trueCode
  JMP(_end)
_false:
  falseCode
_end:
}


// Does {code} if the current character has an itemId
command if_has_item(itemId, code) {
  LDA_d(PARTY_ID)
  LDX_i(itemId)
  JSL(0xC45683) // findItemInInventory(characterId, itemId)
  // (there's two copies of that function; this is the version supports 0xFF=all characterss, but more
  // importantly it's an RTL function)
  CMP_i(0)
  BEQ_a(_end)
  code
_end:
}

// Does {code} if the current character does not have an itemId
command if_not_has_item(itemId, code) {
  LDA_d(PARTY_ID)
  LDX_i(itemId)
  JSL(0xC45683) // findItemInInventory(characterId, itemId)
  // (there's two copies of that function; this is the version supports 0xFF=all characterss, but more
  // importantly it's an RTL function)
  CMP_i(0)
  BNE_a(_end)
  code
_end:
}

// Does {code} if the current character has an itemId, otherwise does {elseCode}
command if_has_item_else(itemId, code, elseCode) {
  LDA_d(PARTY_ID)
  LDX_i(itemId)
  JSL(0xC45683) // findItemInInventory(characterId, itemId)
  // (there's two copies of that function; this is the version supports 0xFF=all characterss, but more
  // importantly it's an RTL function)
  CMP_i(0)
  BEQ_a(_else)
  code
  JMP(_end)
_else:
  falseCode
_end:
}

// Does {code} if character level is >= level
command if_at_least_level(level, code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_LEVEL)
  AND_i(0x00FF)
  CMP_i(level)
  BCC_a(_end)
  code
_end:
}

// Does {code} if character level is < level
command if_less_than_level(level, code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_LEVEL)
  AND_i(0x00FF)
  CMP_i(level)
  BCS_a(_end)
  code
_end:
}

// Does {code} if character level is >= level, otherwise does {elseCode}
command if_at_least_level_else(level, code, elseCode) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_LEVEL)
  AND_i(0x00FF)
  CMP_i(level)
  BCC_a(_else)
  code
  JMP(_end)
_else:
  elseCode
_end:
}

// Does {code} if character minLevel <= level < maxLevel
command if_level_range(minLevel, maxLevel, code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_LEVEL)
  AND_i(0x00FF)
  CMP_i(minLevel)
  BCC_a(_end)
  CMP_i(maxLevel)
  BCS_a(_end)
  code
_end:
}

// Does {code} if character has the matching status ailment (group, ailment)
// Use CHARACTER_STATUS_0, CHARACTER_STATUS_1, etc for group
// Reference on ailment IDs: https://github.com/Herringway/ebsrc/blob/39a0962291563339556417cb01425084c0976977/include/constants/battle.asm#L1
// Alternatively, these numbers are all one less than the status control code
command if_has_status(group, ailment, code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(group)
  AND_i(0x00FF)
  CMP_i(ailment)
  BNE_a(_end)
  code
_end:
}

// Does {code} if character does not have the matching status ailment (group, ailment)
// See if_has_status
command if_lacks_status(group, ailment, code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(group)
  AND_i(0x00FF)
  CMP_i(ailment)
  BEQ_a(_end)
  code
_end:
}

// Does {code} if character has the matching status ailment (group, ailment), otherwise does {elseCode}
// See if_has_status
command if_has_status_else(group, ailment, code, elseCode) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(group)
  AND_i(0x00FF)
  CMP_i(ailment)
  BNE_a(_else)
  code
  JMP(_end)
_else:
  elseCode
_end:
}

// Does {code} if character can move (not paralyzed or immobilized)
// Doesn't bother checking unconscious/diamondized/solidified, since the menu doesn't normally appear for them
command if_can_move(code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_0)
  AND_i(0x00FF)
  CMP_i(3) // paralysis
  BEQ_a(_end)
  LDA_x(CHARACTER_STATUS_2)
  AND_i(0x00FF)
  CMP_i(3) // immobilized
  BEQ_a(_end)
  code
_end:
}

// Does {code} if character can't move (paralyzed or immobilized)
// Doesn't bother checking unconscious/diamondized/solidified, since the menu doesn't normally appear for them
command if_cant_move(code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_0)
  AND_i(0x00FF)
  CMP_i(3) // paralysis
  BEQ_a(_do)
  LDA_x(CHARACTER_STATUS_2)
  AND_i(0x00FF)
  CMP_i(3) // immobilized
  BNE_a(_end)
_do:
  code
_end:
}

// Does {moveCode} if character can move (not paralyzed or immobilized), else does {cantCode}
// Doesn't bother checking unconscious/diamondized/solidified, since the menu doesn't normally appear for them
command if_can_move_else(moveCode, cantCode) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_0)
  AND_i(0x00FF)
  CMP_i(3) // paralysis
  BEQ_a(_cant)
  LDA_x(CHARACTER_STATUS_2)
  AND_i(0x00FF)
  CMP_i(3) // immobilized
  BEQ_a(_cant)
  // Can move
  moveCode
  JMP(_end)
_cant:
  cantCode
_end:
}

// Does {code} if character is confused (mushroomized or feeling strange)
command if_confused(code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_1)
  AND_i(0x00FF)
  CMP_i(1) // mushroomized
  BEQ_a(_do)
  LDA_x(CHARACTER_STATUS_3)
  AND_i(0x00FF)
  CMP_i(1) // feeling strange
  BNE_a(_end)
_do:
  code
_end:
}


// Does {code} if character is not confused (mushroomized or feeling strange)
command if_not_confused(code) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_1)
  AND_i(0x00FF)
  CMP_i(1) // mushroomized
  BEQ_a(_end)
  LDA_x(CHARACTER_STATUS_3)
  AND_i(0x00FF)
  CMP_i(1) // feeling strange
  BEQ_a(_end)
  code
_end:
}

// Does {confusedCode} if character is confused (mushroomized or feeling strange), else does {clearCode}
command if_confused_else(confusedCode, clearCode) {
  LDX_d(PARTY_CHARACTER)
  LDA_x(CHARACTER_STATUS_1)
  AND_i(0x00FF)
  CMP_i(1) // mushroomized
  BEQ_a(_confused)
  LDA_x(CHARACTER_STATUS_3)
  AND_i(0x00FF)
  CMP_i(1) // feeling strange
  BEQ_a(_confused)
  // Clearheaded
  clearCode
  JMP(_end)
_confused:
  confusedCode
_end:
}

// Runs {block} if the character can currently use this PSI.
// Checks character, level, and PP, but does not check "cannot concentrate"
// (This + if_not_confused is equivalent to the check that the autobattle function makes.)
command if_can_use_psi(psiId, block) {
  // Sorry Jeff.
  LDA_d(PARTY_ID)
  CMP_i(3)
  BEQ_a(_end) 
  // Use C45ECE/canUsePsi, which checks level and learnability (but has undefined results for Jeff)
  // A is already the character ID
  LDX_i(psiId)
  JSL(0xC45ECE) // canUsePsi(character, psiId)
  CMP_i(1)
  BNE_a(_end)
  // Check PP
  // I can't believe there's not a helper function in EB for this; it does this computation a zillion times
  LDA_i(psiId)
  LDY_i(15) // sizeof(psi_ability)
  JSL(0xC09032) // mul A * y
  TAX
  LDA_xl(0xD58A54) // PSI Ability table (D58A50) + 4-5th byte in psi ability is action ID
  LDY_i(12) // sizeof(battle_action)
  JSL(0xC09032) // mul A * y
  TAX
  LDA_xl(0xD57B6B) // Actions table (D57B68) + 3rd byte in action is pp cost
  AND_i(0xFF)
  // Compare against user's PP
  LDX_d(PARTY_CHARACTER)
  CMP_x(CHARACTER_PP)
  BCS_a(_end)
  // Okay now you can actually do your thing
  block
_end:
}

// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) has id itemId
command if_equipped_id(equipSlot, itemId, block) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_end) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemId)
  BNE_a(_end)
  block
_end:
}

// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) does not have id itemId
command if_not_equipped_id(equipSlot, itemId, block) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_end) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemId)
  BEQ_a(_end)
  block
_end:
}

// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) has id itemId, otherwise
// runs {elseBlock}
command if_equipped_id_else(equipSlot, itemId, block, elseBlock) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_end) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemId)
  BNE_a(_else)
  block
  JMP(_end)
_else:
  elseBlock
_end:
}


// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) has type itemType
command if_equipped_type(equipSlot, itemType, block) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_end) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Find item data
  LDY_i(39) // sizeOf(item)
  JSL(0xC09032) // mul A * y
  // Load type
  TAX
  LDA_x(0xD55019) // Type is 25 bytes into items struct at 0xD55000
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemType)
  BNE_a(_end)
  block
_end:
}

// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) is not type itemType
command if_not_equipped_type(equipSlot, itemType, block) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_end) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Find item data
  LDY_i(39) // sizeOf(item)
  JSL(0xC09032) // mul A * y
  // Load type
  TAX
  LDA_x(0xD55019) // Type is 25 bytes into items struct at 0xD55000
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemType)
  BEQ_a(_end)
  block
_end:
}

// Runs {block} if the item in equipSlot (SLOT_WEAPON, SLOT_BODY, SLOT_ARMS, SLOT_OTHER) has type itemType,
// otherwise do {elseBlock}
command if_equipped_type_else(equipSlot, itemType, block, elseBlock) {
  // Get which item
  LDX_d(PARTY_CHARACTER)
  LDA_x(equipSlot)
  AND_i(0xFF)
  BEQ_a(_else) // It's 0 if non equipped
  DEC
  // Get what that item is
  CLC
  ADC_d(PARTY_CHARACTER)
  TAX
  LDA_x(CHARACTER_ITEMS)
  AND_i(0xFF)
  // Find item data
  LDY_i(39) // sizeOf(item)
  JSL(0xC09032) // mul A * y
  // Load type
  TAX
  LDA_xl(0xD55019) // Type is 25 bytes into items struct at 0xD55000
  AND_i(0xFF)
  // Do comparison
  CMP_i(itemType)
  BNE_a(_else)
  block
  JMP(_end)
_else:
  elseBlock
_end:
}

// Runs {block} if it's possible to run away from this battle
command if_runnable(block) {
  JSL_RTS_C2(0xC2AB14)
  CMP_i(1) // returns 1 when runnable
  BNE_a(_end)
  block
_end:
}

// Runs {block} if it' nots possible to run away from this battle
command if_not_runnable(block) {
  JSL_RTS_C2(0xC2AB14)
  CMP_i(1) // returns 1 when runnable
  BEQ_a(_end)
  block
_end:
}

// Runs {block} if it's possible to run away from this battle, otherwise runs {elseBlock}
command if_runnable_else(block, elseBlock) {
  JSL_RTS_C2(0xC2AB14)
  CMP_i(1) // returns 1 when runnable
  BNE_a(_else)
  block
  JMP(_end)
_else:
  elseBlock
_end:
}


// Sets the targetting type according to the current action, and chooses a random valid target.
command auto_target() {
  JSR(AutoTarget) // It's a long function, avoided copy-pasting it by adding a label
  XBA // Because I copied C1ADB4, which is the wrong way around too, I need to also swap the bytes
  STA_a(BATTLE_SELECTION_TARGETTING)
}

// Tries the game's built in lifeup target-finder. If a target is found, doe the following:
// - sets the target to the found one
// - sets the target flags to targetType. This should be ONE_ALLY or ALL_ALLIES
// - runs {block}
// - sets target's isAutoHealed property. This prevents functions like this from targetting that character again
//   until the start of the next turn.
// A good target according to EB has less than 25% health, is conscious, and does not have isAutoHealed set.
// If there are multiple good targets, it chooses the one with the least health.
command if_lifeup_target(targetType, block) {
  JSL(0xC4A15D) // autoLifeup
  CMP_i(0)
  BEQ_a(_end)
  // Combine result target with targetting type
  ORA_i(targetType)
  XBA
  STA_a(BATTLE_SELECTION_TARGETTING)
  block
_end:
}

// Tries the game's built in healing target-finder. If a target is found, doe the following:
// - sets the target to the found one
// - sets the target flags to targetType. This should be ONE_ALLY or ALL_ALLIES
// - runs {block}
// - sets target's isAutoHealed property. This prevents functions like this from targetting that character again
//   until the start of the next turn.
// A good target according to EB has this status (status + statusGroup) and does not have isAutoHealed set.
// If there are multiple good targets, it chooses the one with the least health. (Least health doesn't make a
// lot of sense for healing, but EB does it anyway.)
command if_healing_target(targetType, statusGroup, status, block) {
  LDX_i(status)
  LDA_i(statusGroup)
  JSL(0xC4A0CF) // autoHealing
  CMP_i(0)
  BEQ_a(_end)
  // Combine result target with targetting type
  ORA_i(targetType)
  XBA
  STA_a(BATTLE_SELECTION_TARGETTING)
  block
_end:
}

// Runs {block} if at least n characters are alive
command if_at_least_n_characters(n, block) {
  count_characters()
  CMP_i(n)
  BCC_a(_end)
  block
_end:
}

// Counts player characters and returns in A
command count_characters() {
  LDA_i(0)
  JSL(0xC2BAC5)
}

// Counts enemies and returns in A
command count_enemies() {
  LDA_i(1)
  JSL(0xC2BAC5)
}

// Runs {block} if the current giygas phase is phase
command if_giygas_phase(phase, block) {
  LDA_a(0x7eA97A)
  CMP_i(phase)
  BNE_a(_end)
  block
_end:
}


// Internal / defines
// Global auto-fight enable flag
define AUTO_FIGHT_ENABLE = 0x7E98B1 // game_state(7E97F5) + autoFightEnable (188)
// Array of which party member is in which slot
define PARTY_INDEX = 0x7E986F // game_state(7E97F5) + partyMemberIndex (122)

// Another global, inexplicably not part of the selection struct
define BATTLE_ITEM_USED = 0xA97C // 1 byte

// These get returned via a global struct at $A97D
define BATTLE_SELECTION = 0xA97D // Start of struct, used as a pointer value
define BATTLE_SELECTION_USER = 0xA97D // 1 byte, used by psi menu and goods menu
define BATTLE_SELECTION_PARAM1 = 0xA97E // 1 byte; item slot (not ID) or PSI ID for action argument
define BATTLE_SELECTION_ACTION = 0xA97F // 2 bytes
define BATTLE_SELECTION_TARGETTING = 0xA981 // 1 byte, but determineTargetting joins it with the target
define BATTLE_SELECTION_TARGET = 0xA982 // 1 byte

define COUNT_FRONT_ROW = 0x7EAD56
define COUNT_BACK_ROW = 0x7EAD58

// Stack variables
define PARTY_ID = 0x00 // Current kid's ID (1 Ness, 2 Paula, etc)
define PARTY_ORDER = 0x02 // Current kid's order (0 is first, the one with auto-battle)
define PARTY_CHARACTER = 0x04 // Current kid's character struct pointer
define SCRATCH_VAL = 0x06
define MINUS_STACK_SIZE = -0x20

// Indexes into the character struct
define CHARACTER_NAME = 0 // 5 bytes
define CHARACTER_LEVEL = 5 // byte
define CHARACTER_STATUS_0 = 14 // byte, "PERSISTENT_EASYHEAL" - exists out of battle and a horn of life works
define CHARACTER_STATUS_1 = 15 // byte, "PERSISTENT_HARDHEAL" - mushroom and possession
define CHARACTER_STATUS_2 = 16 // byte, "TEMPORARY" - cured after battle (asleep, crying, immobilzied, solidified)
define CHARACTER_STATUS_3 = 17 // byte, "STRANGENESS"
define CHARACTER_STATUS_4 = 18 // byte, "CONCENTRATION"
define CHARACTER_STATUS_5 = 19 // byte, "HOMESICKNESS"
define CHARACTER_STATUS_6 = 20 // byte, "SHIELD"
define CHARACTER_ITEMS = 35 // 14 bytes
define SLOT_WEAPON = 49 // byte, index into inventory struct
define SLOT_BODY = 50 // byte, index into inventory struct
define SLOT_ARMS = 51 // byte, index into inventory struct
define SLOT_OTHER = 52 // byte, index into inventory struct
define CHARACTER_PP = 77 // short, this one is "pp target" technically, but it's the one we want

// Random helpful functions
define RAND_MOD = 0xC45F7B // short randMod(short arg) -- unsigned

// Lifeup/heal targetting values
define ALL_ALLIES = 0x0400
define ONE_ALLY = 0x0100

// Internals
// Override the main battle menu
// This gets called once per character
ROM[0xC2311B] = JML(NewMenu)

// Defines the menu. The user's stuff is included by inlining battle_menu
NewMenu:
  // Standard EB style function intro
  REP (0x31)
  PHD
  PHA
  TDC
  ADC_i(MINUS_STACK_SIZE)
  TCD
  PLA
  // Save party member ID and order from arguments
  STA_d(PARTY_ID)
  TXA
  STA_d(PARTY_ORDER)
  // Compute party member's spot
  LDA_d(PARTY_ID)
  DEC
  LDY_i(95) // sizeof(char_struct)
  JSL(0xC09032) // mul A * y
  CLC
  ADC_i(0x99CE) // char struct array
  STA_d(PARTY_CHARACTER)
  // Swap off to auto battle if enabled
  LDA_a(AUTO_FIGHT_ENABLE)
  AND_i(0xFF)
  BEQ_a(_notAuto)
  JSR(AutoFightAi)
  JMP(_endMenu)
_notAuto:  
  // Some palette thing that EB calls before starting this menu
  LDA_i(0)
  JSL(0xC2FEF9)
  JSL(0xEF0262) // enableHalfHPMeterSpeed
  battle_menu
	JSL(0xEF026E) // resumeHPPPRolling()
_endMenu:

  // Set flags based on action, needed for character animation
  //if_character_id(1, {
  //  if_character_action(8, {
	//	set_flag(NESS_DEF_FLAG, 1)
	//})
    //JMP(_endMenu2)
  //})
  if_character_id(2, {
	if_character_action(0, {	// If the menu was cancelled
		set_flag(NESS_DEF_FLAG, 0)
		set_flag(NESS_PSI_FLAG, 0)
		set_flag(NESS_GOODS_FLAG, 0)
	})
    if_character_action(8, {
		set_flag(PAULA_DEF_FLAG, 1)
	})
    JMP(_endMenu2)
  })
  if_character_id(3, {
  	if_character_action(0, {
		set_flag(PAULA_DEF_FLAG, 0)
		set_flag(PAULA_PSI_FLAG, 0)
		set_flag(PAULA_GOODS_FLAG, 0)
		set_flag(PAULA_PRAY_FLAG, 0)
	})
    if_character_action(8, {
		set_flag(JEFF_DEF_FLAG, 1)
	})
    JMP(_endMenu2)
  })
  if_character_id(4, {
    if_character_action(0, {
		set_flag(JEFF_DEF_FLAG, 0)
		set_flag(JEFF_SPY_FLAG, 0)
		set_flag(JEFF_GOODS_FLAG, 0)
	})
	if_character_action(8, {
		set_flag(POO_DEF_FLAG, 1)
	})
    JMP(_endMenu2)
  })
  
  
  

  // For some reason, this function returns the action, even though it's already in BATTLE_SELECTION_ACTION
_endMenu2:
  LDA_a(BATTLE_SELECTION_ACTION)
  // EB function outro
  PLD
  RTL

// This is roughly a copy of C1ADB4 / determineTargetting, but with random instead of the menu
// Returns the combined BATTLE_SELECTION_TARGETTING in A
AutoTarget:
	// Look up entry in actions table
	LDA_a(BATTLE_SELECTION_ACTION)
	LDY_i(12) // sizeof(action)
	JSL(0xC09032) // mul A * y
	TAX
	// First bytes are target+direction; we need to handle every combo separately, so just do that
	// Also we're translating from (decomp names:) ActionDirection+ActionType to Targetted
	// https://github.com/Herringway/earthbound/blob/7e1d00365ae1f2edc8e6cfdd5f8de2dce36e667d/source/earthbound/commondefs.d#L4354C23-L4354C23
	// Which doesn't have much of a pattern, so it's just a bunch of arbitrary numbers
	LDA_xl(0xD57B68) // action table + 0
	CMP_i(0x0000) // enemy+none
	BEQ_a(_enemyNone)
	CMP_i(0x0100) // enemy+one
	BEQ_a(_enemyOne)
	CMP_i(0x0200) // enemy+random
	BEQ_a(_enemyOne) // same as enemy+one because we're random
	CMP_i(0x0300) // enemy+row
	BEQ_a(_enemyRow)
	CMP_i(0x0400) // enemy+all
	BEQ_a(_enemyAll)
	CMP_i(0x0001) // party+none
	BEQ_a(_partyNone)
	CMP_i(0x0101) // party+one
	BEQ_a(_partyOne)
	CMP_i(0x0201) // party+random
	BEQ_a(_partyOne) // same as party+one because we're random
	CMP_i(0x0301) // party+row
	BEQ_a(_partyAll) // row and all are same for party
	CMP_i(0x0401) // party+all
	BEQ_a(_partyAll)
	// Uh... invalid? Gonna make a call and say enemy+random is the best default
	JMP(_enemyOne)
_enemyNone:
  LDA_i(0x1100) // enemies + single
  ORA_d(PARTY_ID) // I have no idea why the game puts this here
  RTS
_enemyOne:
  // Pick a random enemy
  count_enemies()
  DEC
  JSL(RAND_MOD)
  INC
  ORA_i(0x1100) // enemies + single
  RTS
_enemyRow:
  LDA_a(COUNT_FRONT_ROW)
  BEQ_a(_backRow)
  LDA_a(COUNT_BACK_ROW)
  BEQ_a(_frontRow)
  // Both rows exist so pick at random
  LDA_i(2)
  JSL(RAND_MOD)
  BEQ_a(_frontRow)
  _backRow:
    LDA_i(0x1201) // enemies + row + back row
    RTS
  _frontRow:
    LDA_i(0x1200) // enemies + row + front row
    RTS
_enemyAll:
  LDA_i(0x1400) // enemies + all
  RTS
_partyNone:
  LDA_i(0x0100) // allies + single
  ORA_d(PARTY_ID) // I have no idea why the game puts this here
  RTS
_partyOne:
  // Pick a random party member
  count_characters()
  DEC
  JSL(RAND_MOD)
  // Look up which party member is in that slot
  TAX
  LDA_x(PARTY_INDEX)
  AND_i(0x00FF)
  ORA_i(0x0100) // allies + single
  RTS
_partyAll:
  LDA_i(0x0400) // allies + all
  RTS